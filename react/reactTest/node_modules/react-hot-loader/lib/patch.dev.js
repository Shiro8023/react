'use strict';

var _global = require('global');

var _global2 = _interopRequireDefault(_global);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _updateCounter = require('./updateCounter');

var _proxies = require('./reconciler/proxies');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const hooks = {
  register(type, uniqueLocalName, fileName) {
    (0, _updateCounter.didUpdate)();

    if (typeof type !== 'function') {
      return;
    }
    if (!uniqueLocalName || !fileName) {
      return;
    }
    if (typeof uniqueLocalName !== 'string' || typeof fileName !== 'string') {
      return;
    }
    const id = fileName + '#' + uniqueLocalName; // eslint-disable-line prefer-template

    (0, _proxies.updateProxyById)(id, type);
  },

  reset(useWeakMap) {
    (0, _proxies.resetProxies)(useWeakMap);
  },

  warnings: true,
  disableComponentProxy: false
};

hooks.reset();

function resolveType(type) {
  var _REACT_HOT_LOADER__ = __REACT_HOT_LOADER__;
  const disableComponentProxy = _REACT_HOT_LOADER__.disableComponentProxy;
  // We only care about composite components

  if (typeof type !== 'function') {
    return type;
  }

  // always could...
  const couldWrapWithProxy = true;

  // is proxing is disabled - do not create auto proxies, but use the old ones
  const proxy = !disableComponentProxy && couldWrapWithProxy ? (0, _proxies.createProxyForType)(type) : (0, _proxies.getProxyByType)(type);

  if (!proxy) {
    return type;
  }

  return proxy.get();
}

const originalCreateElement = _react2.default.createElement;

const childrenOnly = _react2.default.Children.only;

function patchedCreateElement(type, ...args) {
  // Trick React into rendering a proxy so that
  // its state is preserved when the class changes.
  // This will update the proxy if it's for a known type.
  const resolvedType = resolveType(type);
  return originalCreateElement(resolvedType, ...args);
}

patchedCreateElement.isPatchedByReactHotLoader = true;

function patchedCreateFactory(type) {
  // Patch React.createFactory to use patched createElement
  // because the original implementation uses the internal,
  // unpatched ReactElement.createElement
  const factory = patchedCreateElement.bind(null, type);
  factory.type = type;
  return factory;
}

patchedCreateFactory.isPatchedByReactHotLoader = true;

function patchedChildOnly(element) {
  return childrenOnly(Object.assign({}, element, {
    type: resolveType(element.type)
  }));
}

if (typeof _global2.default.__REACT_HOT_LOADER__ === 'undefined') {
  _react2.default.createElement = patchedCreateElement;
  _react2.default.createFactory = patchedCreateFactory;
  _react2.default.Children.only = patchedChildOnly;
  _global2.default.__REACT_HOT_LOADER__ = hooks;
}